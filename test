using Neo.SmartContract.Framework;
using Neo.SmartContract.Framework.Services.Neo;
using Neo.SmartContract.Framework.Services.System;
using System;
using System.Numerics;

namespace newNeo
{
    public class Contract1 : SmartContract
    {
        public delegate object NEP5Contract(string method, object[] args);
        public static Object Main(string operation, byte[] originator, Object[] args)
        {
            Runtime.Notify("starting main function");
            if (originator == new byte[] { })
            {
                Runtime.Notify("empty originator");
                return false;
            }

            if (operation == "deploy")
            {
                Runtime.Notify("calling deploy");
                return deploy(originator);
            }
            if (operation == "changeApprover")
            {
                if (args.Length != 1)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return changeApprover(originator, (byte[])args[0]);
            }
            if (operation == "addAuthorizedAddress")
            {
                if (args.Length != 1)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return addAuthorizedAddress(originator, (byte[])args[0]);
            }
            if (operation == "removeAuthorizedAddress")
            {
                if (args.Length != 1)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return removeAuthorizedAddress(originator, (byte[])args[0]);
            }
            if (operation == "updateFeeSchedule")
            {
                if (args.Length != 3)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return updateFeeSchedule((BigInteger)args[0], (BigInteger)args[1], (BigInteger)args[2]);
            }
            if (operation == "calcTradeFee")
            {
                if (args.Length != 2)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return calcTradeFee((int)args[0], (int)args[1]);
            }
            if (operation == "calcTradeFeeMulti")
            {
                if (args.Length != 2)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return calcTradeFeeMulti((uint[])args[0], (int[])args[1]);
            }
            if (operation == "addOwner")
            {
                if (args.Length != 1)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return AddOwner((byte[])args[0]);
            }
            if (operation == "removeOwner")
            {
                if (args.Length != 1)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return removeOwner((byte[])args[0]);
            }
            if (operation == "getKey")
            {
                if (args.Length != 2)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return getKey((byte[])args[0], (string)args[1]);
            }
            if (operation == "openVault")
            {
                if (args.Length != 2)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return openVault((int)args[0], (int)args[1]);
            }
            if (operation == "extendVault")
            {
                if (args.Length != 1)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return extendVault((BigInteger)args[0]);
            }
            if (operation == "closeVault")
            {
                return closeVault();
            }
            if (operation == "storeInVault")
            {
                if (args.Length != 2)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return storeInVault((byte[])args[0], (byte[])args[1]);
            }
            if (operation == "sealVault")
            {
                return sealVault();
            }
            if (operation == "orderCount")
            {
                return getNumberOfOrders();
            }
            if (operation == "orderLocated")
            {
                if (args.Length != 2)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return orderLocated((byte[])args[0], (byte[])args[1]);
            }
            if (operation == "updateVault")
            {
                if (args.Length != 1)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return updateVault((byte[])args[0]);
            }
            if (operation == "updateWallet")
            {
                if (args.Length != 1)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return updateWallet((byte[])args[0]);
            }
            if (operation == "validExchangeFee")
            {
                if (args.Length != 4)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return validExchangeFee((byte[])args[0], (byte[])args[1], (BigInteger)args[2], (BigInteger)args[3]);
            }
            if (operation == "getTwoWayOrderHash")
            {
                if (args.Length != 7)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return getTwoWayOrderHash((Object[])args[0], (Object[])args[1], (BigInteger[])args[2], (BigInteger[])args[3], (Object[])args[4], (BigInteger[])args[5], (byte[])args[6]);
            }
            if (operation == "getOrderHash")
            {
                if (args.Length != 8)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return getOrderHash((Object[])args[0], (BigInteger[])args[1], (BigInteger)args[2], (BigInteger)args[3], (byte[])args[4], (byte[])args[5], (byte[])args[6], (byte[])args[7]);
            }
            if (operation == "getHash")
            {
                if (args.Length != 8)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return getHash((byte[])args[0], (byte[])args[1], (byte[])args[2], (byte[])args[3], (byte[])args[4], (byte[])args[5], (byte[])args[6], (byte[])args[7]);
            }
            if (operation == "OneWayFullfillPO")
            {
                if (args.Length != 12)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return OneWayFullfillPO(originator, (Object[])args[0], (Object[])args[1], (BigInteger[])args[2], (BigInteger[])args[3], (Object[])args[4],
            (BigInteger[])args[5], (byte[])args[11]);
            }
            if (operation == "transferToken")
            {
                if (args.Length != 6)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return transferTokens((Object[])args[0], (Object[])args[1], (BigInteger[])args[2], (BigInteger[])args[3], (Object[])args[4], (BigInteger[])args[5]);
            }
            if (operation == "orderExists")
            {
                if (args.Length != 2)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return orderExists((byte[])args[0], (byte[])args[1]);
            }
            if (operation == "validateAuthorization")
            {
                if (args.Length != 6)
                {
                    Runtime.Notify("invalid arguments...");
                    return false;
                }
                return validateAuthorization((object[])args[0], (object[])args[1], (BigInteger[])args[2], (BigInteger[])args[3], (Object[])args[4], (BigInteger[])args[5]);
            }
            Runtime.Notify("Not matching...");
            return false;
        }
        public static bool deploy(byte[] originator)
        {
            Runtime.Notify(originator);
            Storage.Put(Storage.CurrentContext, "approver", originator);
            Storage.Put(Storage.CurrentContext, "vaultSealed", 2);
            Storage.Put(Storage.CurrentContext, "isVaultOpened", 2);
            byte[] newOwner = getKey(originator, "Owner");
            Storage.Put(Storage.CurrentContext, newOwner, 1);
            Storage.Put(Storage.CurrentContext, "orderCount", 0);
            Storage.Put(Storage.CurrentContext, "activated", 1);
            Storage.Put(Storage.CurrentContext, "wallet", originator);
            RuntimeNotify("deploy successful");
            return true;
        }
        public static bool changeApprover(byte[] originator, byte[] newApprover)//onlyApprover 
        {
            Runtime.Notify(originator,newApprover);
            byte[] approver = Storage.Get(Storage.CurrentContext, "approver");
            if (newApprover != new byte[] { 0 })
            {
                Storage.Put(Storage.CurrentContext, "approver", newApprover);
                Runtime.Notify("successful");
                return true;
            }
            return false;
        }

        private static bool addAuthorizedAddress(byte[] originator, byte[] appIntegrator)  //onlyApprover 
        {
            Runtime.Notify(originator,appIntegrator);
            byte[] index = getKey(appIntegrator, "authorized");
            Storage.Put(Storage.CurrentContext, index, 1);
            Runtime.Notify("successful");
            return true;
        }

        private static bool removeAuthorizedAddress(byte[] originator, byte[] appIntegrator) //onlyApprover 
        {
            Runtime.Notify(originator,appIntegrator);
            byte[] index = getKey(appIntegrator, "authorized");
            Storage.Delete(Storage.CurrentContext, index);
            Runtime.Notify("successful");
            return true;
        }
        public static Object updateFeeSchedule(BigInteger _baseTokenFee, BigInteger _etherFee, BigInteger _normalTokenFee)
        {
            Runtime.Notify(_baseTokenFee,_etherFee,_normalTokenFee);
            if (_baseTokenFee < 0 && _baseTokenFee > 1 * 1) //<= 1*1 ether
            {
                return false;
            }
            if (_etherFee < 0 && _etherFee > 1 * 1)  //1*1ether
            {
                return false;
            }
            if (_normalTokenFee < 0)
            {
                return false;
            }
            Storage.Put(Storage.CurrentContext, "BaseTokenFee", _baseTokenFee);
            Storage.Put(Storage.CurrentContext, "EtherTokenFee", _etherFee);
            Storage.Put(Storage.CurrentContext, "NormalTokenFee", _normalTokenFee);
            Runtime.Notify("success");
            return true;
        }
        public static Boolean verify(byte[] _owner)
        {
            Runtime.Notify(_owner);
            bool result = Runtime.CheckWitness(_owner);
            return result;
        }

        /*_feeIndex will be 0 for BaseTokenFee
         * _feeIndex will be 1 for EtherTokenFee
         * _feeIndex will be 2 for NormalTokenFee*/
        public static int calcTradeFee(int _value, int _feeIndex)
        {
            int tokenFees = 0;
            if (_feeIndex < 0 && _feeIndex > 2)
            {
                Runtime.Notify("wrong feeIndex");
                return 0;
            }
            if (_value < 0)
            {
                Runtime.Notify("value cannot be zero");
                return 0;
            }
            if (_feeIndex == 0)
            {
                tokenFees = (int)new BigInteger(Storage.Get(Storage.CurrentContext, "BaseTokenFee"));
            }
            if (_feeIndex == 1)
            {
                tokenFees = (int)new BigInteger(Storage.Get(Storage.CurrentContext, "EtherTokenFee"));
            }
            if (_feeIndex == 2)
            {
                tokenFees = (int)new BigInteger(Storage.Get(Storage.CurrentContext, "NormalTokenFee"));
            }
            if (tokenFees == 0)
            {
                return 0;
            }

            Runtime.Notify(_value,_feeIndex);
            int _totalFees = (_value * (tokenFees)) / (1);//1 ether
            if (_totalFees < 0)
            {
                return 0;
            }
            Runtime.Notify("Success");
            return _totalFees;
        }
        public static int[] calcTradeFeeMulti(uint[] __values, int[] __feeIndexes)
        {
            int[] _values = new int[__values.Length];
            int[] _feeIndexes = new int[__feeIndexes.Length];
            int[] empty = new int[_values.Length];
            for (int j = 0; j < _values.Length; j++)
            {
                _values[j] = (int)__values[j];
                _feeIndexes[j] = (int)__feeIndexes[j];
            }
            if (_values.Length <= 0)
            {
                return empty;
            }
            if (_feeIndexes.Length <= 0)
            {
                return empty;
            }
            if (_values.Length != _feeIndexes.Length)
            {
                return empty;
            }
            int[] _totalFees = new int[_values.Length];
            for (int i = 0; i < _values.Length; i++)
            {
                _totalFees[i] = calcTradeFee(_values[i], _feeIndexes[i]);
            }
            if (_totalFees.Length <= 0)
            {
                return empty;
            }
            if (_values.Length != _totalFees.Length)
            {
                return empty;
            }
            Runtime.Notify("Success");
            return _totalFees;
        }
        public static bool AddOwner(byte[] _newOwner)//OnlyApprover
        {
            byte[] newOwner = getKey(_newOwner, "Owner");
            Storage.Put(Storage.CurrentContext, newOwner, 1);
            //vaultOwners.push(newOwner); 
            Runtime.Notify("Success");
            return true;
        }
        public static bool removeOwner(byte[] _owner)//OnlyApprover
        {
            byte[] newOwner = getKey(_owner, "Owner");
            Storage.Delete(Storage.CurrentContext, newOwner);
            Runtime.Notify("Success");
            return true;
        }
        public static byte[] getKey(byte[] key1, string key2)
        {
            return key1.Concat(Neo.SmartContract.Framework.Helper.AsByteArray(key2));
        }
        public static bool openVault(int stTime, int edTime)
        {
            BigInteger startTime = (BigInteger)stTime;
            BigInteger endTime = (BigInteger)edTime;
            byte[] vaultSealed = (Storage.Get(Storage.CurrentContext, "vaultSealed"));
            byte[] isVaultOpened = (Storage.Get(Storage.CurrentContext, "isVaultOpened"));

            //should check
            BigInteger _currTime = 10;// Runtime.Time;

            if (new BigInteger(vaultSealed) != 1 && new BigInteger(isVaultOpened) != 1 && (startTime >= _currTime) && (endTime >= _currTime) && (startTime < endTime))
            {
                Storage.Put(Storage.CurrentContext, "startTime", startTime);
                Storage.Put(Storage.CurrentContext, "endTime", endTime);
                Storage.Put(Storage.CurrentContext, "isVaultOpened", 1);
                Runtime.Notify("Success");
                return true;
            }
            return false;
        }
        public static bool extendVault(BigInteger endTime)
        {
            byte[] vaultSealed = (Storage.Get(Storage.CurrentContext, "vaultSealed"));

            byte[] _startTime = (Storage.Get(Storage.CurrentContext, "startTime"));
            byte[] _endTime = (Storage.Get(Storage.CurrentContext, "endTime"));
            BigInteger _currTime = 20;// Runtime.Time;
            if (endTime >= new BigInteger(_startTime) && new BigInteger(vaultSealed) != 1 && endTime >= _currTime && new BigInteger(_startTime) <= _currTime)
            {
                Storage.Put(Storage.CurrentContext, "endTime", endTime);
                Storage.Put(Storage.CurrentContext, "isVaultOpened", 1);
                Runtime.Notify("vault extended");
                return true;
            }
            return false;
        }
        public static bool closeVault()
        {
            byte[] vaultSealed = (Storage.Get(Storage.CurrentContext, "vaultSealed"));
            byte[] isVaultOpened = (Storage.Get(Storage.CurrentContext, "isVaultOpened"));
            if (new BigInteger(vaultSealed) != 1 && new BigInteger(isVaultOpened) == 1)
            {
                Storage.Put(Storage.CurrentContext, "isVaultOpened", 2);
                //should check for Runtime.Time
                Storage.Put(Storage.CurrentContext, "endTime", 100);// Runtime.Time);
                Runtime.Notify("vault closed");
                return true;
            }
            return false;
        }
        public static bool storeInVault(byte[] orderHash, byte[] orderID)
        {
            byte[] vaultSealed = (Storage.Get(Storage.CurrentContext, "vaultSealed"));
            byte[] isVaultOpened = (Storage.Get(Storage.CurrentContext, "isVaultOpened"));

            byte[] _startTime = (Storage.Get(Storage.CurrentContext, "startTime"));
            byte[] _endTime = (Storage.Get(Storage.CurrentContext, "endTime"));
            BigInteger _currTime = 50;// Runtime.Time;
            if (new BigInteger(vaultSealed) != 1 && new BigInteger(isVaultOpened) == 1 && new BigInteger(_endTime) > new BigInteger(_startTime) && new BigInteger(_startTime) <= _currTime && new BigInteger(_endTime) >= _currTime)
            {
                byte[] _orderHashKey = getKey(orderHash, "orderHash");
                byte[] _orderIDKey = getKey(orderID, "orderId");
                byte[] _count = (Storage.Get(Storage.CurrentContext, "orderCount"));
                BigInteger newCount = new BigInteger(_count) + 1;
                Storage.Put(Storage.CurrentContext, _orderHashKey, 1);
                Storage.Put(Storage.CurrentContext, _orderIDKey, 1);
                Storage.Put(Storage.CurrentContext, "orderCount", newCount);
                Runtime.Notify("stored in vault");
                return true;
            }
            return false;
        }
        public static bool sealVault()
        {
            byte[] vaultSealed = (Storage.Get(Storage.CurrentContext, "vaultSealed"));
            if (new BigInteger(vaultSealed) != 1)
            {
                Storage.Put(Storage.CurrentContext, "vaultSealed", (BigInteger)1);
                Storage.Put(Storage.CurrentContext, "isVaultOpened", (BigInteger)2);
                //Runtime.Time
                Storage.Put(Storage.CurrentContext, "endTime", 100);// Runtime.Time);
                Runtime.Notify("vault sealed");
                return true;
            }
            return false;
        }
        public static byte[] getNumberOfOrders()
        {
            return Storage.Get(Storage.CurrentContext, "orderCount");
        }
        public static bool orderLocated(byte[] _hash, byte[] _orderID)
        {
            bool result = false;
            byte[] _orderHashKey = getKey(_hash, "orderHash");
            byte[] _orderIDKey = getKey(_orderID, "orderId");
            BigInteger isHashPresent = Neo.SmartContract.Framework.Helper.AsBigInteger(Storage.Get(Storage.CurrentContext, _orderHashKey));
            BigInteger isOrderPresent = Neo.SmartContract.Framework.Helper.AsBigInteger(Storage.Get(Storage.CurrentContext, _orderIDKey));
            if (isHashPresent == 1 && isOrderPresent == 1)
            {
                result = true;
            }
            return result;
        }
        public static bool updateVault(byte[] newOwer)
        {
            byte[] _approver = Storage.Get(Storage.CurrentContext, "approver");
            byte[] addr = new byte[] { };
            if (newOwer == addr && _approver == newOwer)
                return false;
            sealVault();
            Storage.Put(Storage.CurrentContext, "vaultSealed", 2);
            Storage.Put(Storage.CurrentContext, "isVaultOpened", 2);
            byte[] newOwner = getKey(newOwer, "Owner");
            Storage.Put(Storage.CurrentContext, newOwner, 1);
            Storage.Put(Storage.CurrentContext, "approver", newOwer);
            return true;
        }

        //updateExConfig
        public static bool updateWallet(byte[] _wallet)
        {
            Storage.Put(Storage.CurrentContext, "wallet", _wallet);
            return true;
        }

        public static bool validExchangeFee(byte[] _sellerFeeToken, byte[] _buyerFeeToken, BigInteger _sellerFeeValue, BigInteger _buyerFeeValue)
        {
            byte[] addr = new byte[] { };
            if (_sellerFeeToken == addr || _buyerFeeToken == addr || _sellerFeeValue <= 0 || _buyerFeeValue <= 0)
            {
                return false;
            }
            return true;
        }
        public static byte[] getTwoWayOrderHash(Object[] _sellerTokens, Object[] _buyerTokens, BigInteger[] _sellerValues, BigInteger[] _buyerValues, Object[] _orderAddresses, BigInteger[] _orderValues, byte[] _orderId)
        {
            byte[] _sellerHash = getOrderHash(_sellerTokens, _sellerValues, _orderValues[3], _orderValues[0], (byte[])_orderAddresses[3], (byte[])_orderAddresses[0], (byte[])_orderAddresses[1], _orderId);
            byte[] _buyerHash = getOrderHash(_buyerTokens, _buyerValues, _orderValues[4], _orderValues[1], (byte[])_orderAddresses[4], (byte[])_orderAddresses[0], (byte[])_orderAddresses[2], _orderId);
            byte[] Hash = _sellerHash.Concat(_buyerHash).Concat(_orderId);

            return Hash256(_sellerHash.Concat(_buyerHash).Concat(_orderId));
        }
        public static byte[] getOrderHash(Object[] _tokens, BigInteger[] _counts, BigInteger _pValue, BigInteger _fValue, byte[] _feeToken, byte[] _maker, byte[] _signer, byte[] _orderID)
        {
            byte[] bytes1 = (byte[])_tokens[0];

            for (int i = 1; i < _tokens.Length; i++)
            {
                bytes1 = bytes1.Concat((byte[])_tokens[i]);
            }
            byte[] bytes2 = Neo.SmartContract.Framework.Helper.AsByteArray(_counts[0]);
            for (int i = 1; i < _counts.Length; i++)
            {
                bytes2 = bytes2.Concat(Neo.SmartContract.Framework.Helper.AsByteArray(_counts[i]));
            }
            return getHash(bytes1, bytes2, Neo.SmartContract.Framework.Helper.AsByteArray(_pValue), Neo.SmartContract.Framework.Helper.AsByteArray(_fValue), _feeToken, _maker, _signer, _orderID);
        }
        private static byte[] getHash(byte[] _token, byte[] _counts, byte[] _pvalue, byte[] _fvalue, byte[] _feeToken, byte[] _maker, byte[] _signer, byte[] _orderId)
        {
            var bytes = ExecutionEngine.ExecutingScriptHash.Concat(_token).Concat(_counts).Concat(_pvalue).Concat(_fvalue).Concat(_feeToken).Concat(_maker).Concat(_signer).Concat(_orderId);
            return Hash256(bytes);
        }
        public static bool OneWayFullfillPO(byte[] _originator, Object[] _sellerTokens, Object[] _buyerTokens, BigInteger[] _sellerValues, BigInteger[] _buyerValues, Object[] _orderAddresses,
            BigInteger[] _orderValues, byte[] _orderID)
        {
            //include code for signature check
            byte[] index = getKey(_originator, "authorized");
            byte[] authorized = (Storage.Get(Storage.CurrentContext, index));
            byte[] _isActivated = (Storage.Get(Storage.CurrentContext, "activated"));
            if (new BigInteger(_isActivated) != 1 || _orderValues[2] >= 10 && new BigInteger(authorized) != 1)//checkwitness[_orderAddresses of 1 and 2] and //Runtime.Time
                return false;
            byte[] _sellerHash = getOrderHash(_sellerTokens, _sellerValues, _orderValues[3], _orderValues[0], (byte[])_orderAddresses[3], (byte[])_orderAddresses[0], (byte[])_orderAddresses[1], _orderID);
            byte[] _buyerHash = getOrderHash(_buyerTokens, _buyerValues, _orderValues[4], _orderValues[1], (byte[])_orderAddresses[4], (byte[])_orderAddresses[0], (byte[])_orderAddresses[2], _orderID);
            if (orderExists(Hash256(_sellerHash.Concat(_buyerHash).Concat(_orderID)), _orderID))
            {
                Runtime.Notify("order exists");
                return false;
            }
            if (!validExchangeFee((byte[])_orderAddresses[3], (byte[])_orderAddresses[4], _orderValues[0], _orderValues[1]))
            {
                Runtime.Notify("fee is not valid");
                return false;
            }
            _orderValues[0] = calcTradeFee((int)_orderValues[0], (int)_orderAddresses[3]);
            _orderValues[1] = calcTradeFee((int)_orderValues[1], (int)_orderAddresses[4]);
            if (_orderValues[0] <= 0 && _orderValues[1] <= 0) return false;

            if (_orderAddresses[0] == new byte[] { 0x0 } && _orderAddresses[1] == new byte[] { 0x0 } && _orderAddresses[2] == new byte[] { 0x0 } && _orderAddresses[1] == _orderAddresses[2]) return false; //buyer

            if (_sellerTokens.Length <= 0 && _sellerTokens.Length != _sellerValues.Length) return false;

            if (_buyerTokens.Length <= 0 && _buyerTokens.Length != _buyerValues.Length) return false;

            //need to check
            if (!validateAuthorization(_sellerTokens, _buyerTokens, _sellerValues, _buyerValues, _orderAddresses, _orderValues))
            {
                return false;
            }
            bool result = transferTokens(_sellerTokens, _buyerTokens, _sellerValues, _buyerValues, _orderAddresses, _orderValues);
            if (result != true) return false;
            return storeInVault(Hash256(_sellerHash.Concat(_buyerHash).Concat(_orderID)), _orderID);
        }
        public static bool transferTokens(Object[] _sellerTokens, Object[] _buyerTokens, BigInteger[] _sellerValues, BigInteger[] _buyerValues, Object[] _orderAddresses, BigInteger[] _orderValues)
        {
            int len = _sellerTokens.Length;
            byte[] token;
            var arg = new Object[] { };
            for (int i = 0; i < len; i++)
            {
                arg = new Object[] { _orderAddresses[1], _orderAddresses[2], _sellerValues[i] };
                token = (byte[])_sellerTokens[i];
                //check
                var sellerContract = (NEP5Contract)token.ToDelegate();
                sellerContract("transfer", arg);
            }
            len = _buyerTokens.Length;
            for (int i = 0; i < len; i++)
            {
                token = (byte[])_buyerTokens[i];
                arg = new Object[] { _orderAddresses[2], _orderAddresses[1], _buyerValues[i] };
                //check
                var buyerContract = (NEP5Contract)token.ToDelegate();
                buyerContract("transfer", arg);
            }
            //exchange fee
            byte[] wallet = Storage.Get(Storage.CurrentContext, "wallet");

            token = (byte[])_orderAddresses[3];
            arg = new Object[] { _orderAddresses[1], wallet, _orderValues[0] };
            //check
            var Contract = (NEP5Contract)token.ToDelegate();
            Contract("transfer", arg);

            token = (byte[])_orderAddresses[4];
            arg = new object[] { _orderAddresses[2], wallet, _orderValues[1] };
            //check
            Contract = (NEP5Contract)token.ToDelegate();
            Contract("transfer", arg);

            return true;
        }

        public static bool orderExists(byte[] _hash, byte[] _orderID)
        {
            if (orderLocated(_hash, _orderID))
            {
                return true;
            }
            return false;
        }

        public static bool validateAuthorization(object[] _sellerTokens, object[] _buyerTokens, BigInteger[] _sellerValues, BigInteger[] _buyerValues, Object[] _orderAddresses, BigInteger[] _orderValues)
        {
            var arg = new Object[] { _orderAddresses[2], (byte[])ExecutionEngine.ExecutingScriptHash };
            byte[] token = (byte[])_orderAddresses[4];
            //check contract invoke
            var Contract = (NEP5Contract)token.ToDelegate();
            var result = (BigInteger)Contract("allowance", arg);
            if (result <= _orderValues[1]) return false;

            arg = new Object[] { _orderAddresses[1], (byte[])ExecutionEngine.ExecutingScriptHash };
            token = (byte[])_orderAddresses[3];
            //Should check
            Contract = (NEP5Contract)token.ToDelegate();
            result = (BigInteger)Contract("allowance", arg);

            if (result <= _orderValues[0]) return false;

            for (uint i = 0; i < _buyerTokens.Length; i++)
            {
                arg = new Object[] { _orderAddresses[2], (byte[])ExecutionEngine.ExecutingScriptHash };
                token = (byte[])_buyerTokens[i];
                //Should check
                var buyertoken = (NEP5Contract)token.ToDelegate();
                result = (BigInteger)buyertoken("allowance", arg);
                if (result <= _buyerValues[i]) return false;
            }
            for (uint i = 0; i < _sellerTokens.Length; i++)
            {
                arg = new Object[] { _orderAddresses[1], (byte[])ExecutionEngine.ExecutingScriptHash };
                token = (byte[])_sellerTokens[i];
                //check
                var sellertoken = (NEP5Contract)token.ToDelegate();
                result = (BigInteger)sellertoken("allowance", arg);

                if (result <= _sellerValues[i]) return false;
            }
            return true;
        }
        public static bool verify(byte[] _owner)
        {
            bool result;
            result=Runtime.CheckWitness(_owner);
            return result;
        }
        /*public static bool isOrderSigned(byte[] _msgHash, BigInteger v, byte[] r, byte[] s, byte[] _signer)
        {
            return false;// ecverify(_msgHash, v, r, s, _signer);
        }*/
    }
}
