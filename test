using Neo.SmartContract.Framework;
using Neo.SmartContract.Framework.Services.Neo;
using Neo.SmartContract.Framework.Services.System;
using System;
using System.Numerics;

namespace newNeo
{
    public class Contract1 : SmartContract
    {
        //static int[] exFees = new int[3];
        public delegate object NEP5Contract(string method, object[] args);
        public static Object Main(string operation, byte[] originator, Object[] args)
        {
            Runtime.Notify("starting main function");
            if (operation == "getTwoWayOrderHash")
            {
                Runtime.Notify("getTwoWayOrderHash calling");
                return getTwoWayOrderHash((Object[])args[0], (Object[])args[1], (BigInteger[])args[2], (BigInteger[])args[3], (Object[])args[4], (BigInteger[])args[5], (byte[])args[6]);
                //getHash((byte[]) args[0], (byte[])args[1],(byte[]) args[2],(byte[]) args[3], (byte[]) args[4], (byte[]) args[5], (byte[]) args[6], (byte[]) args[7]);
            }
            if(operation== "getOrderHash")
            {
                return getOrderHash((Object[])args[0],(BigInteger[]) args[1], (BigInteger) args[2], (BigInteger) args[3], (byte[]) args[4], (byte[]) args[5], (byte[]) args[6], (byte[]) args[7]);
            }
            if (operation == "getHash")
                return getHash((byte[]) args[0], (byte[]) args[1], (byte[]) args[2], (byte[]) args[3], (byte[]) args[4], (byte[]) args[5], (byte[]) args[6], (byte[]) args[7]);
            if (operation == "orderExists")
            {
                return orderExists((byte[])args[0], (byte[])args[1]);
            }
            if(operation== "validateAuthorization")
            {
                return validateAuthorization((object[]) args[0], (object[]) args[1], (BigInteger[]) args[2], (BigInteger[]) args[3], (Object[]) args[4], (BigInteger[]) args[5]);
            }
            if (operation == "transferToken")
            {
                return transferTokens((Object[])args[0], (Object[])args[1], (BigInteger[])args[2], (BigInteger[])args[3], (Object[])args[4], (BigInteger[])args[5]);
            }
            Runtime.Notify("checking for deploy");
            if (operation == "deploy")
            {
                Runtime.Notify("calling deploy");
                return deploy(originator);
            }
            if (operation == "changeApprover")
            {
                return changeApprover(originator, (byte[])args[0]);
            }
            if (operation == "addAuthorizedAddress")
            {
                return addAuthorizedAddress(originator, (byte[])args[0]);
            }
            if (operation == "removeAuthorizedAddress")
            {
                return removeAuthorizedAddress(originator, (byte[])args[0]);
            }
            if (operation == "updateFeeSchedule")
            {
                return updateFeeSchedule((BigInteger)args[0], (BigInteger)args[1], (BigInteger)args[2]);
            }
            if (operation == "calcTradeFee")
            {
                return calcTradeFee((int)args[0], (int)args[1]);
            }
            if (operation == "calcMultiTradeFee")
            {
                return calcTradeFeeMulti((uint[])args[0], (int[])args[1]);
            }
            if (operation == "addOwner")
            {
                return AddOwner((byte[])args[0]);
            }
            if (operation == "removeOwner")
            {
                return removeOwner((byte[])args[0]);
            }
            if (operation == "getKey")
                return getKey((byte[])args[0], (string)args[1]);
            if (operation == "openVault")
            {
                return openVault((int)args[0], (int)args[1]);
            }
            if (operation == "extendVault")
            {
                return extendVault((BigInteger)args[0]);
            }
            if (operation == "closeVault")
            {
                return closeVault();
            }
            Runtime.Notify("checking for store in vault...");
            if (operation == "storeInvault")
            {
                Runtime.Notify("yes");
                return storeInVault((byte[])args[0], (byte[])args[1]);
            }
            if (operation == "sealVault")
            {
                sealVault();
            }
            if (operation == "orderCount")
            {
                return getNumberOfOrders();
            }
            if (operation == "orderLocated")
            {
                return orderLocated((byte[])args[0], (byte[])args[1]);
            }
            if (operation == "updateVault")
            {
                return updateVault((byte[])args[0]);
            }
            if (operation == "updateWallet")
            {
                return updateWallet((byte[])args[0]);
            }
            if (operation == "validExchangeFee")
            {
                return validExchangeFee((byte[])args[0], (byte[])args[1], (BigInteger)args[2], (BigInteger)args[3]);
            }
            if (operation == "OneWayFullfillPO")
            {
                return OneWayFullfillPO(originator, (Object[]) args[0], (Object[]) args[1], (BigInteger[]) args[2], (BigInteger[]) args[3], (Object[]) args[4],
            (BigInteger[]) args[5], (BigInteger[]) args[6], (byte[]) args[7], (byte[]) args[8], (byte[]) args[9], (byte[]) args[10], (byte[]) args[11]);
            }
            if (operation == "checkings")
            {
                Runtime.Notify(ExecutionEngine.ExecutingScriptHash);
                Transaction tx = (Transaction)ExecutionEngine.ScriptContainer;
                TransactionOutput[] reference = tx.GetReferences();
                // you can choice refund or not refund
                foreach (TransactionOutput output in reference)
                {
                    Runtime.Notify(output.ScriptHash);
                }
                return 10;
            }
            Storage.Put(Storage.CurrentContext, "Hello", "World");
            return false;
        }
        public static bool deploy(byte[] originator)
        {
            Storage.Put(Storage.CurrentContext, "approver", originator);
            Storage.Put(Storage.CurrentContext, "vaultSealed", 2);
            Storage.Put(Storage.CurrentContext, "isVaultOpened", 2);
            byte[] newOwner = getKey(originator, "Owner");
            Storage.Put(Storage.CurrentContext, newOwner, 1);
            Storage.Put(Storage.CurrentContext, "orderCount", 0);
            Storage.Put(Storage.CurrentContext, "activated", 1);
            Storage.Put(Storage.CurrentContext, "wallet", originator);
            return true;
        }
        public static bool changeApprover(byte[] originator, byte[] newApprover)//onlyApprover 
        {
            byte[] approver = Storage.Get(Storage.CurrentContext, "approver");
            if (newApprover != new byte[] { 0 })
            {
                Storage.Put(Storage.CurrentContext, "approver", newApprover);
                //LogApproverChanged(originator, approver, newApprover);
                return true;
            }
            return false;
        }

        private static bool addAuthorizedAddress(byte[] originator, byte[] appIntegrator)  //onlyApprover 
        {
            byte[] index = getKey(appIntegrator, "authorized");
            Storage.Put(Storage.CurrentContext, index, 1);
            //LogAuthorizedAddressAdded(originator, appIntegrator);
            return true;
        }

        private static bool removeAuthorizedAddress(byte[] originator, byte[] appIntegrator) //onlyApprover 
        {
            byte[] index = getKey(appIntegrator, "authorized");
            Storage.Delete(Storage.CurrentContext, index);
            //LogAuthorizedAddressRemoved(originator, appIntegrator);
            return true;
        }
        public static Object updateFeeSchedule(BigInteger _baseTokenFee, BigInteger _etherFee, BigInteger _normalTokenFee)
        {
            if (_baseTokenFee < 0 && _baseTokenFee > 1 * 1) //<= 1*1 ether
            {
                return false;
            }
            if (_etherFee < 0 && _etherFee > 1 * 1)  //1*1ether
            {
                return false;
            }
            if (_normalTokenFee < 0)
            {
                return false;
            }
            Storage.Put(Storage.CurrentContext, "BaseTokenFee", _baseTokenFee);
            Storage.Put(Storage.CurrentContext, "EtherTokenFee", _etherFee);
            Storage.Put(Storage.CurrentContext, "NormalTokenFee", _normalTokenFee);
            return true;
        }
        public static Boolean verify(byte[] _owner)
        {
            bool result = Runtime.CheckWitness(_owner);
            return result;
        }
        public static int calcTradeFee(int _value, int _feeIndex)
        {
            int tokenFees = 0;
            Runtime.Notify(10);
            if (_feeIndex < 0 && _feeIndex > 2)
            {
                Runtime.Notify(11);
                return 0;
            }
            if (_value < 0)
            {
                Runtime.Notify(12);
                return 0;
            }
            if (_feeIndex == 0)
            {
                Runtime.Notify(13);
                tokenFees = (int)new BigInteger(Storage.Get(Storage.CurrentContext, "BaseTokenFee"));
            }
            if (_feeIndex == 1)
            {
                Runtime.Notify(14);
                tokenFees = (int)new BigInteger(Storage.Get(Storage.CurrentContext, "EtherTokenFee"));
            }
            if (_feeIndex == 2)
            {
                Runtime.Notify(15);
                tokenFees = (int)new BigInteger(Storage.Get(Storage.CurrentContext, "NormalTokenFee"));
            }
            if (tokenFees == 0)
            {
                Runtime.Notify(16);
                return 0;
            }

            Runtime.Notify(17);
            int _totalFees = (_value * (tokenFees)) / (1);//1 ether
            if (_totalFees < 0)
            {
                Runtime.Notify(18);
                return 0;
            }
            Runtime.Notify(19);
            return _totalFees;
        }
        public static int[] calcTradeFeeMulti(uint[] __values, int[] __feeIndexes)
        {
            Runtime.Notify(1);
            int[] _values = new int[__values.Length];
            int[] _feeIndexes = new int[__feeIndexes.Length];
            int[] empty = new int[_values.Length];
            Runtime.Notify(2);
            for (int j = 0; j < _values.Length; j++)
            {
                Runtime.Notify("in for loop1");
                _values[j] = (int)__values[j];
                _feeIndexes[j] = (int)__feeIndexes[j];
            }
            if (_values.Length <= 0)
            {
                Runtime.Notify(3);
                return empty;
            }
            if (_feeIndexes.Length <= 0)
            {
                Runtime.Notify(4);
                return empty;
            }
            if (_values.Length != _feeIndexes.Length)
            {
                Runtime.Notify(5);
                return empty;
            }
            Runtime.Notify(6);
            int[] _totalFees = new int[_values.Length];
            for (int i = 0; i < _values.Length; i++)
            {
                Runtime.Notify("in for loop2");
                _totalFees[i] = calcTradeFee(_values[i], _feeIndexes[i]);
            }
            if (_totalFees.Length <= 0)
            {
                Runtime.Notify(7);
                return empty;
            }
            Runtime.Notify(_values.Length, _totalFees.Length, _totalFees, _values);
            if (_values.Length != _totalFees.Length)
            {
                Runtime.Notify(8);
                return empty;
            }
            Runtime.Notify(9);
            return _totalFees;
        }
        public static bool AddOwner(byte[] _newOwner)//OnlyApprover
        {
            byte[] newOwner = getKey(_newOwner, "Owner");
            Storage.Put(Storage.CurrentContext, newOwner, 1);
            //vaultOwners.push(newOwner); 
            return true;
        }
        public static bool removeOwner(byte[] _owner)//OnlyApprover
        {
            byte[] newOwner = getKey(_owner, "Owner");
            Storage.Delete(Storage.CurrentContext, newOwner);
            return true;
        }
        public static byte[] getKey(byte[] key1, string key2)
        {
            return key1.Concat(Neo.SmartContract.Framework.Helper.AsByteArray(key2));
        }
        public static bool openVault(int stTime, int edTime)
        {
            BigInteger startTime = (BigInteger)stTime;
            BigInteger endTime = (BigInteger)edTime;
            BigInteger vaultSealed = new BigInteger(Storage.Get(Storage.CurrentContext, "vaultSealed"));
            BigInteger isVaultOpened = new BigInteger(Storage.Get(Storage.CurrentContext, "isVaultOpened"));

            //should check
            BigInteger _currTime = 10;// Runtime.Time;

            if ((vaultSealed != 1) && (isVaultOpened != 1) && (startTime >= _currTime) && (endTime >= _currTime) && (startTime < endTime))
            {
                Storage.Put(Storage.CurrentContext, "startTime", startTime);
                Storage.Put(Storage.CurrentContext, "endTime", endTime);
                Storage.Put(Storage.CurrentContext, "isVaultOpened", 1);
                return true;
            }
            return false;
        }
        public static bool extendVault(BigInteger endTime)
        {
            byte[] vaultSealed = (Storage.Get(Storage.CurrentContext, "vaultSealed"));
            Runtime.Notify(new BigInteger(vaultSealed));

            byte[] _startTime = (Storage.Get(Storage.CurrentContext, "startTime"));
            byte[] _endTime = (Storage.Get(Storage.CurrentContext, "endTime"));
            BigInteger _currTime = 600;// Runtime.Time;
            Runtime.Notify(_startTime, _endTime, _currTime, endTime);
            if (endTime >= new BigInteger(_startTime) && new BigInteger(vaultSealed) != 1 && endTime >= _currTime && new BigInteger(_startTime) <= _currTime)
            {
                Runtime.Notify("_start if");
                Storage.Put(Storage.CurrentContext, "endTime", endTime);
                Storage.Put(Storage.CurrentContext, "isVaultOpened", 1);
                Runtime.Notify("end if");
                return true;
            }
            return false;
        }
        public static bool closeVault()
        {
            byte[] vaultSealed = (Storage.Get(Storage.CurrentContext, "vaultSealed"));
            byte[] isVaultOpened = (Storage.Get(Storage.CurrentContext, "isVaultOpened"));
            if (new BigInteger(vaultSealed) != 1 && new BigInteger(isVaultOpened) == 1)
            {
                Runtime.Notify("is");
                Storage.Put(Storage.CurrentContext, "isVaultOpened", 2);
                //should check for Runtime.Time
                Storage.Put(Storage.CurrentContext, "endTime", Runtime.Time);
                return true;
            }
            return false;
        }
        public static bool storeInVault(byte[] orderHash, byte[] orderID)
        {
            Runtime.Notify("beginning");
            byte[] vaultSealed = (Storage.Get(Storage.CurrentContext, "vaultSealed"));
            byte[] isVaultOpened = (Storage.Get(Storage.CurrentContext, "isVaultOpened"));

            byte[] _startTime = (Storage.Get(Storage.CurrentContext, "startTime"));
            byte[] _endTime = (Storage.Get(Storage.CurrentContext, "endTime"));
            Runtime.Notify("entering if");
            BigInteger _currTime = 150;// Runtime.Time;
            if (new BigInteger(vaultSealed) != 1 && new BigInteger(isVaultOpened) == 1 && new BigInteger(_endTime) > new BigInteger(_startTime) && new BigInteger(_startTime) <= _currTime && new BigInteger(_endTime) >= _currTime)
            {
                Runtime.Notify("in if");
                byte[] _orderHashKey = getKey(orderHash, "orderHash");
                byte[] _orderIDKey = getKey(orderID, "orderId");
                Runtime.Notify("middle");
                BigInteger _count = new BigInteger(Storage.Get(Storage.CurrentContext, "orderCount"));
                _count = _count + 1;
                Runtime.Notify("increamented", _count);
                Storage.Put(Storage.CurrentContext, _orderHashKey, 1);
                Storage.Put(Storage.CurrentContext, _orderIDKey, 1);
                Storage.Put(Storage.CurrentContext, "orderCount", _count);
                Runtime.Notify(_orderHashKey, _orderIDKey);
                return true;
            }
            return false;
        }
        public static bool sealVault()
        {
            byte[] vaultSealed = (Storage.Get(Storage.CurrentContext, "vaultSealed"));
            if (new BigInteger(vaultSealed) != 1)
            {
                Runtime.Notify("111 one hudred and eleven");
                Storage.Put(Storage.CurrentContext, "vaultSealed", 1);
                Storage.Put(Storage.CurrentContext, "isVaultOpened", 2);
                //Runtime.Time
                Storage.Put(Storage.CurrentContext, "endTime", Runtime.Time);
                return true;
            }
            return false;
        }
        public static byte[] getNumberOfOrders()
        {
            return Storage.Get(Storage.CurrentContext, "orderCount");
        }
        public static bool orderLocated(byte[] _hash, byte[] _orderID)
        {
            bool result = false;
            byte[] _orderHashKey = getKey(_hash, "orderHash");
            byte[] _orderIDKey = getKey(_orderID, "orderId");
            Runtime.Notify(_orderHashKey, _orderIDKey);
            BigInteger isHashPresent = Neo.SmartContract.Framework.Helper.AsBigInteger(Storage.Get(Storage.CurrentContext, _orderHashKey));
            BigInteger isOrderPresent = Neo.SmartContract.Framework.Helper.AsBigInteger(Storage.Get(Storage.CurrentContext, _orderIDKey));
            Runtime.Notify(isHashPresent, isOrderPresent);
            if (isHashPresent == 1 && isOrderPresent == 1)
            {
                Runtime.Notify("in if");
                result = true;
            }
            return result;
        }
        public static bool updateVault(byte[] newOwer)
        {
            Runtime.Notify(1);
            byte[] _approver = Storage.Get(Storage.CurrentContext, "approver");
            byte[] addr = new byte[] { };
            Runtime.Notify(2);
            if (newOwer == addr && _approver == newOwer)
                return false;
            Runtime.Notify(3);
            sealVault();
            Runtime.Notify(4);
            Storage.Put(Storage.CurrentContext, "vaultSealed", 2);
            Storage.Put(Storage.CurrentContext, "isVaultOpened", 2);
            Runtime.Notify(5);
            byte[] newOwner = getKey(newOwer, "Owner");
            Storage.Put(Storage.CurrentContext, newOwner, 1);
            Runtime.Notify(6);
            //Storage.Put(Storage.CurrentContext, "approver", newOwer);
            return true;
        }
        //updateExConfig
        public static bool updateWallet(byte[] _wallet)
        {
            Storage.Put(Storage.CurrentContext, "wallet", _wallet);
            return true;
        }
        public static bool isOrderSigned(byte[] _msgHash, BigInteger v, byte[] r, byte[] s, byte[] _signer)
        {
            return false;// ecverify(_msgHash, v, r, s, _signer);
        }
        public static bool validExchangeFee(byte[] _sellerFeeToken, byte[] _buyerFeeToken, BigInteger _sellerFeeValue, BigInteger _buyerFeeValue)
        {
            byte[] addr = new byte[] { };
            Runtime.Notify("entering in if...");
            if (_sellerFeeToken == addr || _buyerFeeToken == addr || _sellerFeeValue <= 0 || _buyerFeeValue <= 0)
            {
                Runtime.Notify("in if");
                return false;
            }
            return true;
        }
        public static byte[] getTwoWayOrderHash(Object[] _sellerTokens, Object[] _buyerTokens, BigInteger[] _sellerValues, BigInteger[] _buyerValues, Object[] _orderAddresses, BigInteger[] _orderValues, byte[] _orderId)
        {
            Runtime.Notify("func invoking");
            byte[] _sellerHash = getOrderHash(_sellerTokens, _sellerValues, _orderValues[3], _orderValues[0], (byte[])_orderAddresses[3], (byte[])_orderAddresses[0], (byte[])_orderAddresses[1], _orderId);
            Runtime.Notify(1);
            byte[] _buyerHash = getOrderHash(_buyerTokens, _buyerValues, _orderValues[4], _orderValues[1], (byte[])_orderAddresses[4], (byte[])_orderAddresses[0], (byte[])_orderAddresses[2], _orderId);
            Runtime.Notify(2);
            byte[] Hash = _sellerHash.Concat(_buyerHash).Concat(_orderId);
            Runtime.Notify("ret");
            return Hash256(_sellerHash.Concat(_buyerHash).Concat(_orderId));
        }
        public static byte[] getOrderHash(Object[] _tokens, BigInteger[] _counts, BigInteger _pValue, BigInteger _fValue, byte[] _feeToken, byte[] _maker, byte[] _signer, byte[] _orderID)
        {
            Runtime.Notify(0);
            byte[] bytes1 = (byte[])_tokens[0];
            Runtime.Notify("10");
            for (int i = 1; i < _tokens.Length; i++)
            {
                Runtime.Notify(11);
                bytes1 = bytes1.Concat((byte[])_tokens[i]);
                Runtime.Notify(12);
            }
            byte[] bytes2 = Neo.SmartContract.Framework.Helper.AsByteArray(_counts[0]);
            Runtime.Notify(13);
            for (int i = 1; i < _counts.Length; i++)
            {
                Runtime.Notify(14);
                bytes2 = bytes2.Concat(Neo.SmartContract.Framework.Helper.AsByteArray(_counts[i]));
                Runtime.Notify(15);
            }
            Runtime.Notify(16);
            return getHash(bytes1, bytes2, Neo.SmartContract.Framework.Helper.AsByteArray(_pValue), Neo.SmartContract.Framework.Helper.AsByteArray(_fValue), _feeToken, _maker, _signer, _orderID);
        }
        private static byte[] getHash(byte[] _token, byte[] _counts, byte[] _pvalue, byte[] _fvalue, byte[] _feeToken, byte[] _maker, byte[] _signer, byte[] _orderId)
        {
            var bytes = _token.Concat(_counts).Concat(_pvalue).Concat(_fvalue).Concat(_feeToken).Concat(_maker).Concat(_signer).Concat(_orderId);
            return Hash256(bytes);
        }
        public static bool OneWayFullfillPO(byte[] _originator, Object[] _sellerTokens, Object[] _buyerTokens, BigInteger[] _sellerValues, BigInteger[] _buyerValues, Object[] _orderAddresses,
            BigInteger[] _orderValues, BigInteger[] _v, byte[] _br, byte[] _bs, byte[] _sr, byte[] _ss, byte[] _orderID)
        {
            //include code for signature check
            byte[] index = getKey(_originator, "authorized");
            Runtime.Notify(1);
            byte[] authorized = (Storage.Get(Storage.CurrentContext, index));
            byte[] _isActivated = (Storage.Get(Storage.CurrentContext, "activated"));
            Runtime.Notify(2);
            if (new BigInteger(_isActivated) != 1 || _orderValues[2] >= 10 && new BigInteger(authorized) != 1)//checkwitness[_orderAddresses of 1 and 2] and //Runtime.Time
                return false;
            Runtime.Notify(3);
            byte[] _sellerHash = getOrderHash(_sellerTokens, _sellerValues, _orderValues[3], _orderValues[0], (byte[])_orderAddresses[3], (byte[])_orderAddresses[0], (byte[])_orderAddresses[1], _orderID);
            Runtime.Notify(4);
            byte[] _buyerHash = getOrderHash(_buyerTokens, _buyerValues, _orderValues[4], _orderValues[1], (byte[])_orderAddresses[4], (byte[])_orderAddresses[0], (byte[])_orderAddresses[2], _orderID);
            Runtime.Notify(5);
            if (orderExists(Hash256(_sellerHash.Concat(_buyerHash).Concat(_orderID)), _orderID))
            {
                Runtime.Notify(6);
                return false;
            }
            if (!validExchangeFee((byte[])_orderAddresses[3], (byte[])_orderAddresses[4], _orderValues[0], _orderValues[1]))
            {
                Runtime.Notify(7);
                return false;
            }
            _orderValues[0] = calcTradeFee((int)_orderValues[0], (int)_orderAddresses[3]);
            _orderValues[1] = calcTradeFee((int)_orderValues[1], (int)_orderAddresses[4]);
            Runtime.Notify(_orderValues[0],_orderValues[1]);
            Runtime.Notify("eight");
            if (_orderValues[0] <= 0 && _orderValues[1] <= 0) return false;

            Runtime.Notify(9);
            if (_orderAddresses[0] == new byte[] { 0x0 } && _orderAddresses[1] == new byte[] { 0x0 } && _orderAddresses[2] == new byte[] { 0x0 } && _orderAddresses[1] == _orderAddresses[2]) return false; //buyer

            Runtime.Notify(10);
            if (_sellerTokens.Length <= 0 && _sellerTokens.Length != _sellerValues.Length) return false;

            Runtime.Notify(11);
            if (_buyerTokens.Length <= 0 && _buyerTokens.Length != _buyerValues.Length) return false;

            Runtime.Notify(12);
            //need to check
            if (!validateAuthorization(_sellerTokens, _buyerTokens, _sellerValues, _buyerValues, _orderAddresses, _orderValues))
            {
                Runtime.Notify(13);
                return false;
            }
            Runtime.Notify("CHECK1");
            bool result=transferTokens(_sellerTokens, _buyerTokens, _sellerValues, _buyerValues, _orderAddresses, _orderValues);
            Runtime.Notify(14);
            if (result != true) return false;
            Runtime.Notify("what");
            return storeInVault(Hash256(_sellerHash.Concat(_buyerHash).Concat(_orderID)), _orderID);
            Runtime.Notify(15);
            return false;
        }
        public static bool transferTokens(Object[] _sellerTokens, Object[] _buyerTokens, BigInteger[] _sellerValues, BigInteger[] _buyerValues, Object[] _orderAddresses, BigInteger[] _orderValues)
        {
            int len = _sellerTokens.Length;
            byte[] token;
            var arg = new Object[] { };
            for (int i = 0; i < len; i++)
            {
                arg = new Object[] { _orderAddresses[1], _orderAddresses[2], _sellerValues[i] };
                token = (byte[])_sellerTokens[i];
                //var sellerContract = (NEP5Contract)token.ToDelegate();
                //sellerContract("transfer", arg);
            }
            len = _buyerTokens.Length;
            for (int i = 0; i < len; i++)
            {
                token = (byte[])_buyerTokens[i];
                arg = new Object[] { _orderAddresses[2], _orderAddresses[1], _buyerValues[i] };
                //var buyerContract = (NEP5Contract)token.ToDelegate();
                //buyerContract("transfer", arg);
            }
            //exchange fee
            byte[] wallet = Storage.Get(Storage.CurrentContext, "wallet");

            token = (byte[])_orderAddresses[3];
            arg = new Object[] { _orderAddresses[1], wallet, _orderValues[0] };
            //var Contract = (NEP5Contract)token.ToDelegate();
            //Contract("transfer", arg);

            token = (byte[])_orderAddresses[4];
            arg = new object[] { _orderAddresses[2], wallet, _orderValues[1] };
            //Contract = (NEP5Contract)token.ToDelegate();
            //Contract("transfer", arg);
            return true;
        }
        public static bool orderExists(byte[] _hash, byte[] _orderID)
        {
            if (orderLocated(_hash, _orderID))
            {
                return true;
            }
            return false;
        }
        public static bool validateAuthorization(object[] _sellerTokens, object[] _buyerTokens, BigInteger[] _sellerValues, BigInteger[] _buyerValues, Object[] _orderAddresses, BigInteger[] _orderValues)
        {
            var arg = new Object[] { _orderAddresses[2], (byte[])ExecutionEngine.ExecutingScriptHash };
            byte[] token = (byte[])_orderAddresses[4];
            //check contract invoke
            //var Contract = (NEP5Contract)token.ToDelegate();
            var result = (BigInteger)50;// Contract("allowance", arg);
            if (result <= _orderValues[1]) return false;

            arg = new Object[] { _orderAddresses[1], (byte[])ExecutionEngine.ExecutingScriptHash };
            token = (byte[])_orderAddresses[3];
            //Should check
            //Contract = (NEP5Contract)token.ToDelegate();
            //result = (BigInteger)Contract("allowance", arg);

            if (result <= _orderValues[0]) return false;

            for (uint i = 0; i < _buyerTokens.Length; i++)
            {
                arg = new Object[] { _orderAddresses[2], (byte[])ExecutionEngine.ExecutingScriptHash };
                token = (byte[])_buyerTokens[i];
                //Should check
                //var buyertoken = (NEP5Contract)token.ToDelegate();
                //result = (BigInteger)buyertoken("allowance", arg);
                if (result <= _buyerValues[i]) return false;
            }
            for (uint i = 0; i < _sellerTokens.Length; i++)
            {
                arg = new Object[] { _orderAddresses[1], (byte[])ExecutionEngine.ExecutingScriptHash };
                token = (byte[])_sellerTokens[i];
                //check
                //var sellertoken = (NEP5Contract)token.ToDelegate();
                //result = (BigInteger)sellertoken("allowance", arg);

                if (result <= _sellerValues[i]) return false;
            }
            return true;
        }
    }
}
